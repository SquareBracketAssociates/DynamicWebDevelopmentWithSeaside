Our first Seaside component will simply display ''Hello world''. Begin by creating a category called 'SeasideBook-Hello' and then create the class ==ScrapBook== as a subclass of +index:WAComponent+ ==WAComponent== as shown below.==WAComponent subclass: #ScrapBook==    instanceVariableNames: ''==    classVariableNames: ''==    poolDictionaries: ''==    category: 'SeasideBook-Hello'When we use the term ''component'' in this text we generally mean an instance of a subclass of +index:WAComponent+ ==WAComponent==. For now, just think of subclasses of ==WAComponent== as ``visual components\''. When it is time for a component to be displayed, Seaside sends it the message +index:WAComponent!renderContentOn:+ ==WAComponent>>renderContentOn:== with a single argument (by convention called ==html==) which is an instance of the class +index:WARenderCanvas+ ==WARenderCanvas== (the ``canvas\''). Think of the canvas as the medium on which you will paint your component. It provides a transparent interface to XHTML which makes it easy to produce text, anchors, images etc., in a modular way (i.e., attached to each component of your application). To start, we just want to show a simple text message. Fortunately the canvas supports a ==text:== message for just this purpose, which we can use as shown below.@@important Note that all the classes in Seaside are prefixed with ==WA== which acts as a namespace. Do not use this prefix for your components. ==WA== is intended for Seaside framework classes.==ScrapBook>>renderContentOn: html==   html text: 'Hello world'Great, we have a component but how do we get Seaside to serve it? For now, evaluate the following code in a workspace:==WAAdmin register: ScrapBook asApplicationAt: 'hello'Now open your web browser and go to *http://localhost:8080/hello*, and you should see something very like *ref:helloworld*.+helloworld|width=90%+Seaside added XHTML markup for the skeletal structure of an XHTML document (==html==, ==head== and ==body== tags). OK, so what is happening here? Grossly simplified: When we request this URI, Seaside creates a new instance of our class for us and then sends it +index:WAComponent!renderContentOn:+ ==WAComponent>>renderContentOn:==. After being placed inside a skeleton XHTML document, the XHTML painted onto the canvas is then returned to the web browser to be displayed. +index:rendering!text+@@important Never invoke the method ==renderContentOn:== directly, Seaside will do it for you.You will never need to send your component the message +index:WAComponent!renderContentOn:+ ==WAComponent>>renderContentOn:== since the Seaside framework takes care of that for you.  When it is time to paint your component, Seaside sends it ==renderContentOn:==.  This is very similar to models used in most GUI frameworks where a component (or window) is told to paint itself whenever the windowing system deems necessary. Also, keep this in mind as you work with Seaside: a rendering method is just for displaying a component not changing its state.@@important Your rendering method is just for painting the current state of your component, it shouldn't be concerned with changing that state.