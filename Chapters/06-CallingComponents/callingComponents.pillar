
%+Filling up our contact view.>file://figures/personal-information-view1.png|width=80|label=@ref:personalinformationview1+


!! Calling Components

Seaside applications are based on the definition and composition of components. Each component is responsible for its rendering, its state and its own control flow. Seaside lets us freely compose and ''reuse'' such components to create advanced and dynamic applications. You have already built several components. In this chapter, we will show how to reuse these components by ``calling\'' them in a modal way. Embedding components in other components will be discussed in the following chapter.

!!! Displaying a Component Modally

Seaside components have the ability to specify that another component should be rendered (usually temporarily) in their place. This mechanism is triggered by the message ==call:==. During callback processing, a component may send the message ==call:== with another component as an argument. The component passed as an argument in this way can be referred to as the ''delegate''. The ==call:== method has two effects:

# In subsequent rendering cycles, the delegate will be displayed in place of the original component. This continues until the delegate sends the message ==WAComponent>>answer== to itself.
# The current execution state of the calling method is suspended and does not return a value yet. Instead, Seaside renders the web page in the browser (showing the delegate in place of the original component).

The delegate may be a complex component with its own control flow and state. If the delegate component later sends the message ==answer==, then execution of the (currently suspended) calling method is resumed at the site of the ==call:==. We will explain this mechanism in detail after an example. 

@@note Important From the point of view of a component, it calls another component and that component will (eventually) answer.

!!! Example of Call/Answer

To illustrate that mechanism, let's use the ==ContactListView== and ==ContactView== components developed in earlier chapters. Our goal is simple: in a ==ContactListView== component, we will display a link to edit the contacts (as shown in *@ref:list-contact*), and when the user selects that link, display the ==ContactView== on that ==Contact==. We accomplish this using the ==call:== message.

%+Filling up our contact view.>file://figures/personal-information-view1.png|width=80|label=@ref:personalinformationview1+

%+list-contact|width=90%+

The ==editContact:== method is passed a contact as an argument. It creates a ==ContactView== component for the contact and calls this new component by sending it the message ==call:==.

[[[
ContactListView >> editContact: aContact
    self call: (ContactView new 
        contact: aContact;
        yourself)
]]]

Next, we change the method ==ContactListView>>renderContact:on:== to invoke the method we just defined when the edit link is selected, as below:

[[[
ContactListView >> renderContact: aContact on: html
    html text: aContact name , ' ' , aContact emailAddress.
    html text: ' ('.
    html anchor   " <-- added "
        callback: [ self editContact: aContact ];
        with: 'edit'.
    html space.
    html anchor
        callback: [ self removeContact: aContact ];
         with: 'remove'.
    html text: ')'
]]]

In the previous chapters, the ==save== method of the ==ContactView== component just displayed the contact values using a dialog. Now, using the message ==answer==, we are able to return control from the newly created ==ContactView== component to the ==ContactListView== which created it and called it. Modify the ==ContactView== so that when the user presses ''Save'' it returns to the caller (the ==ContactListView==):

[[[
ContactView >> save
    self answer
]]]

Have a look at the way the method ==editContact:== creates a new instance of ==ContactView== and then passes this instance as an argument to the ==call:== message. When you call a component, you're passing control to that component. When that component is done (in this case the user pressed the ''Save'' button), it will send the message ==answer== to return control to the caller.

Interact with this application now and follow the link. Fill out the resulting form and press the ''Save'' button. Notice that you're back to the ==ContactListView== component. So, you ==call:== another component and when it is done it should ==answer==, returning control of the display to the caller. 

@@note Important You can think of the call/answer pair as the Seaside component equivalent of raising and closing a modal dialog respectively.



