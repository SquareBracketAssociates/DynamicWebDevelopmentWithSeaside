!!Forms
@cha:forms

In this chapter, we describe how to use XHTML forms and controls in Seaside. Controls such as text input fields, popup lists, radio buttons, check boxes, date inputs, and buttons are always created within an XHTML element. In this chapter we show how to create this element and how to use these common controls.



!!! Text Input Fields and Buttons

Let's continue with the same ==Contact== domain model class that we used in *cha:anchors*. We wish to create a form that allows the user to update the name and email address for a ==Contact==. Smalltalkers are generally very careful to separate presentation from the core of the data model, so we will create a component that will hold the user interface code to allow the user to edit the underlying ==Contact== instance:


[[[
WAComponent subclass: #ContactView
    instanceVariableNames: 'contact'
    classVariableNames: ''
    package: 'iAddress'
]]]

Notice that we've specified a ==contact== instance variable; this will be used to hold a reference to the instance of the ==Contact== class that we want to edit. Now we create the accessors for the ==contact== instance variable. 

@@note Look carefully at the ==contact== method below. Before returning the value of the ==contact== instance variable, it checks that it has been set. If it hasn't been set, the code in the block is executed which assigns a sensible value to the variable. This ''lazy initialisation'' is a common idiom in Smalltalk code. At the moment we want to test this component as a stand alone component, so the accessor method will lazily load one of the contacts for us.

[[[
ContactView >> contact
    ^ contact ifNil: [ contact := Contact contacts first ]
]]]

[[[
ContactView >> contact: aContact
    contact := aContact
]]]

Next, we introduce our first new canvas message: the message  ==form==. This method returns an instance of  ==WAFormTag==. The only message in  ==WAFormTag== of interest to us right now is  ==with:== which, as we've seen before, takes an argument and renders that argument between the open and close XHTML tags (i.e. the ==<form>== and ==</form>== tags in this case). Controls such as input fields, buttons, popups, list boxes, and so on must all be placed inside a ==form== element.

@@note Important Forgetting to add the form element is a common mistake. Controls such as input fields, buttons, popups, list boxes etc., must all be placed inside a ==form== tag. If not, they may not be rendered, or they may be rendered but then ignored by the browser.

Our form will have three elements: two text boxes, one each for the name and the email address; and a button for the user to submit their changes.

Let's look first at the text fields for the name and e-mail address inputs. These fields are created by the canvas'  ==textInput== message which returns a  ==WATextInputTag==. For each brush we use two methods ==value:== and ==callback:== . The ==value:== method determines what should be put into this field when it is displayed to the user; here we use the accessor methods on the ==Contact== instance to give these values. The ==callback:== method takes a block that has a single argument. When the user submits the form, the block will have the new contents of the field passed to it using this argument; here we use this to update the ==Contact== instance (via its accessor methods).

Finally we would like our component to have a ''Save'' button. We create a button with the canvas ==submitButton== method, which answers a  ==WASubmitButtonTag==. We assign a callback so that when the user presses this button the message ==save== is sent.

Here's the rendering method which creates two text inputs and a submit
button:


[[[
ContactView >> renderContentOn: html
    html form: [
        html text: 'Name: '.
        html textInput
            callback: [ :value | self contact name: value ];
            value: self contact name.
        html break.
        html text: 'Email address: '.
        html textInput
            callback: [ :value | self contact emailAddress: value ];
            value: self contact emailAddress.
        html break.
        html submitButton
            callback: [ self save ];
            value: 'Save']
]]]

[[[
ContactView >> save
    "For now let's just display the contact information"
    self inform: self contact name , '--' , self contact emailAddress
]]]


@@note In Seaside 3.0, the brushes ==submitButton== and ==textInput== you can also use the message ==value:== and ==with:== interchangeably. They both define the contents of the button of text input field.

When the user's browser submits this form, first all the input callbacks are processed, then the (single) submit button callback will be processed. The order is important because the input callbacks set the corresponding field in the ==Contact== instance. The ==save== method expects those fields to be set before it is invoked.

@@note Important You should remember that Seaside processes all input field callbacks before the submit button callback.

Register this component as a new application called ``contact\'', see *ref:/pharo/first-component/registering* for details. Point your web browser to *http://localhost:8080/contact* and you should see the form as shown in *@ref:personalinformationview1*. Try entering values and submitting the form.

%+personalinformationview1|width=90%+

""Brush Message Summary""
The two following tables show a summary of the most useful  ==textInput== and  ==submitButton== brush methods.


|{!Methods on ==WATextInputTag== |!Description
|  ==callback: aBlock==|Specify a single argument callback block which is passed the string value entered by the user.
|  ==value: aString==|Specify an initial value for the text input. 
|  ==on: aSymbol of: anObject==|This is a convenience method explained in the next section. 


|{!Methods on ==WASubmitButton== |!Description
|  ==callback: aBlock==| Specify a zero-argument callback block which is invoked when the user clicks this button. 
|  ==value: aString==| Specify a label for this submit button.
|  ==on: aSymbol of: anObject==|This is a convenience method explained in the next section.


!!! Convenience Methods

Seaside offers also some convenience methods that make your code shorter. Let's have a look at them. 

""Text input fields."" The initial value of an input field often comes from an accessor method on some class (for example ==self contact name==). Similarly your input field callbacks will often look like those in the previous example, and simply take the text that the user entered and store it using a similar method name (for example ==self contact name: value==). Because this is such a common pattern, text input brushes provide the method  ==on:of:==, which does this automatically for you  so you can write:

[[[
html textInput on: #name of: self contact
]]]

instead of:

[[[
html textInput
   callback: [ :value | self contact name: value ];
   with: self contact name
]]]

""Buttons."" Similarly, the label of a submit button can often be inferred from the name of the method it invokes. Submit button brushes provide the method ==on:of:==, which does this automatically for you allowing you to write one line:

[[[
html submitButton on: #save of: self
]]]
instead of all of this:

[[[
html submitButton
   callback: [ self save ];
   value: 'Save'
]]]

@@note The actual conversion from the selector name to the button label happens by sending ==labelForSelector:== to the second argument. The default implementation of this method simply capitalizes the first letter of the selector and returns a string, but applications might decide to customize that method by overriding it.

""Text fields.""  For text fields, the ==on:of:== method takes the (symbol) name of the property to be edited and the object which holds the property. 

""Specifying method names."" Seaside generates method names from the property names using the usual Smalltalk accessor/mutator naming conventions. For example, a property called ==#name== would use a method called ==name== as an accessor and a method called ==name:== as a mutator. The accessor is used to provide the starting value for the field and the mutator is used in a callback to set the value of the property. 

""Generating labels."" For submit buttons, ==on:of:== takes the name of the method to invoke and the object to which to send the message. It will use the method name to generate a label for the button with a bit of intelligence. The symbol ==#save== becomes the label ``Save\'', whereas the symbol ==#youCanUseCamelCase== becomes ``You Can Use Camel Case\''. If you don't like this translation, use the  ==callback:== and ==value:== methods, as demonstrated in the last section. 

So, putting all these techniques to work, our render method could be changed to:

[[[
ContactView >> renderContentOn: html
    html form: [
        html text: 'Name:'.
        html textInput on: #name of: self contact.
        html break.
        html text: 'Email address:'.
        html textInput on: #emailAddress of: self contact.
        html break.
        html submitButton on: #save of: self ]
]]]

All of the Seaside input components support both the ==on:of:== and the more primitive ==callback:== and ==value:== methods, so we will use whichever form makes our code the more readable. Anchors also support ==on:of:==.

@@important As we mentioned above, controls such as input fields, buttons, popups, list boxes, and so on must all be placed inside a ==form== tag. Typically only a single ==form== tag is needed on a page. ==form== tags ''must not'' be nested but multiple ==form== tags can occur, one after another, on a single page. Only the contents of a single ==form== will be submitted by the web browser though (normally determined by the form in which the user clicked a submit button).


!!! Drop-Down Menus and List Boxes

XHTML provides a single element, ==select==, which can be shown by web browsers as a drop-down menu or a list box, depending on the parameters of the element. In this section, we look at examples of each type. We'll start with a drop-down menu.

For the sake of an example, let's track the gender of each of our contacts. Change the ==Contact== class definition to include the ==gender== instance variable and add the methods which manipulate it, as shown below.

[[[
Object subclass: #Contact
    instanceVariableNames: 'name emailAddress gender'
    classVariableNames: 'Database'
    package: 'iAddress'
]]]

[[[
Contact >> gender
    ^ gender ifNil: [ gender := #Male ]
]]]

[[[
Contact >> isMale
    ^ self gender = #Male
]]]

[[[
Contact >> isFemale
    ^ self gender = #Female
]]]

[[[
Contact >> beMale
    gender := #Male
]]]

[[[
Contact >> beFemale
    gender := #Female
]]]

We would like to add a drop-down menu to our editor that allows the user to indicate the gender of someone in the contact list. The simplest way to do this is with the canvas' ==select== method. This method returns a +index:WASelectTag+ ==WASelectTag==.

The following method shows how the ==select== brush can be parametrized to render a list for gender selection.

[[[
ContactView >> renderContentOn: html
    html form: [
        html text: 'Name:'.
        html textInput on: #name of: self contact.
        html break.
        html text: 'Email address:'.
        html textInput on: #emailAddress of: self contact.
        html break.

        "Drop-Down Menu"
        html text: 'Gender: '.
        html select 
            list: #(#Male #Female);
            selected: self contact gender;
            callback: [ :value |
                value = #Male
                    ifTrue: [ self contact beMale ]
                    ifFalse: [ self contact beFemale ] ].
        html break.

        html submitButton on: #save of: self ]
]]]

Notice that ==selected:== allows us to specify which item is selected by default (when the list is first displayed). Let's update the ==save== method to display the gender as follows:

[[[
ContactView >> save  
    self inform: self contact name , 
        '--' , self contact emailAddress , 
        '--' , self contact gender
]]]

Try the application now. You should see a drop-down menu to select the gender, as shown in *ref:personalInformationView3*.

%+personalInformationView3|width=90%+

Modify the gender input so that it specifies a list size:

[[[
ContactView >> renderContentOn: html
    html form: [
        html text: 'Name:'.
        html textInput on: #name of: self contact.
        html break.
        html text: 'Email address:'.
        html textInput on: #emailAddress of: self contact.
        html break.

        "List Box"
        html text: 'Gender: '.
        html select
            size: 2;
            list: #(#Male #Female);
            selected: self contact gender;
            callback: [ :value | 
                value = #Male
                    ifTrue: [ self contact beMale ]
                    ifFalse: [ self contact beFemale ] ].
        html break.
        html submitButton on: #save of: self]
]]]

@@note Advanced Experienced Smalltalkers will be getting concerned at the length of this method by now. Generally it is considered good practice in Smalltalk to keep your methods to a few lines at most. For the purposes of this exercise, we will be ignoring this good practice, but you may want to think about how you could split this method up.

Now view the application in your browser. Most browsers will show a list rather than a drop-down menu, see *@ref:personalInformationview4*.

%+personalInformationview4|width=90%+

%+index:forms!lists+

""Select Brush Message Summary."" The following table shows a summary of the most important message of the ==select== brush. 

|{!Methods on ==WASelectTag== |!Description
|  ==list: aCollection== | Specify the list of options from which to select. 
|  ==selected: anObject== | Specify the object which should be shown as selected by default. 
|  ==callback: aBlock== | Specify a single-argument callback block which will be passed the object selected by the user.
|  ==size: anInteger== | Specify the number of rows of the list that should be visible. Note, if you don't specify a size, the default on most browsers will be to use a drop-down menu. If you specify a size then most browsers will present the options in a list box. 
| ==on: aSymbol of: anObject==| This is a convenience method as explained previously. 



!!! Radio Buttons

In our gender example above, the list is a bit of overkill. Let's present the user with radio buttons instead. We create radio buttons with the canvas' +index:WARenderCanvas!radioButton+ ==radioButton== message, which returns a +index:WARadioButtonTag+ ==WARadioButtonTag==. Radio buttons are arranged in groups, and radio buttons in a group are mutually exclusive, so only one can be selected at a time. 

We will make two changes to our ==renderContentOn:== method: declare a local variable named ==group== and replace the list code with a radio button definition, as shown in the following method:

[[[
ContactView >> renderContentOn: html
    | group |
    html form: [
        html text: 'Name:'.
        html textInput on: #name of: self contact.
        html break.
        html text: 'Email address:'.
        html textInput on: #emailAddress of: self contact.
        html break.

        "Radio Buttons"
        html text: 'Gender: '.
        group := html radioGroup.
        group radioButton
            selected: self contact isMale;
            callback: [ self contact beMale ].
        html text: 'Male'.
        group radioButton
            selected: self contact isFemale;
            callback: [ self contact beFemale ].
        html text: 'Female'.
        html break.

        html submitButton on: #save of: self ]
]]]

First, we ask the canvas to create a new group using ==radioGroup==. We then ask the group for a new radio button using the message  ==radioButton==. The ==selected:== message determines if the browser will render the page with that button selected. Notice in our example that we select the button if it corresponds to the current value of the ==gender== variable. That way the form reflects the state of our component. 

The ==callback:== method should be a zero argument callback block which is executed when the page is submitted with that radio button selected. Note the callback block is not called for options that were not selected.

%+personalinformationview51|width=90%+


""Radio Button Brush Summary."" The following table gives a summary of the most important ==radioButton== brush messages.


|{!Methods on ==WARadioButtonTag== |!Description
| ==group: aRadioGroup==| Specify the radio group to which this button belongs. 
| ==selected: aBoolean==| Specify a boolean value that indicates whether this radio button  is initially selected. 
| ==callback: aBlock==|Specify a zero argument callback block which is called if this button is selected when the submit button is pressed.














!!! From Anchors to Callbacks

You can generate run-of-the-mill HTML anchors by creating an anchor brush (send ==WAHtmlCanvas>>anchor== to the canvas), then configuring the anchor to be associated with a URL using  ==WAAnchorTag>>url:== and specifying the text for the anchor using ==WAAnchorTag>>with:==. Here is a simple component that displays an anchor that displays a link to the Seaside web site.

[[[
WAComponent subclass: #SimpleAnchor
    instanceVariableNames: ''
    classVariableNames: ''
    package: 'SeasideBook-Anchors'
]]]

[[[
SimpleAnchor >> renderContentOn: html
    html anchor
        url: 'http://www.seaside.st';
        with: 'Seaside Website'
]]]

Register this component as ``simple-anchor\'' then view the component through your browser and you should see a page similar to *@ref:anchor-1*.

%+A simple anchor.>file://figures/simple-anchor.png|width=80|label=ref:anchor-1+

Clicking on the ''Seaside Website'' anchor will bring you to the website.





Note that rather than manipulating strings in this way, experienced Smalltalkers might want to actually define an ``email address\'' class to handle the different representations of email addresses. In fact, Seaside 3.0 already defines a class WAEmailAddress which may be used for this very purpose.







!!! Summary

In this chapter you saw callbacks, a powerful feature of Seaside. Using a callback, we can attach an action or a small program to a link or button that will be executed only when the element is activated. What is really powerful is that you can write any Pharo code in a callback. In the next chapter, we will continue to enhance the iAddress application to show you how to handle forms.
