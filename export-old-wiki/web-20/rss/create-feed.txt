There is a Seaside package extension that helps us to build such feeds in a manner similar to what we used to build XHTML for component rendering. Let's create a news feed for our todo items.""Define the Feed Component."" The package defines a root class named +index:RRComponent+ ==RRComponent== that allows you to describe both the news feed channel (title, description, language, date of publication) and also the news items. Therefore, the next step is to create a new subclass of +index:RRComponent+ ==RRComponent== named ==ToDoRssFeed==. This will be the entry point of our feed generator. In our example, we don't need extra instance variables.==RRComponent subclass: #ToDoRssFeed==    instanceVariableNames: ''==    classVariableNames: ''==    poolDictionaries: ''==    category: 'ToDo-RSS'""Register the Component as Entry Point."" Next we need to register the component at a fixed URL. The aggregator will use this URL to access the feed. We do this by adding a class side initialize method. Don't forget to evaluate the code.==ToDoRssFeed class>>initialize==    (WAAdmin register: RRRssHandler at: 'todo.rss')==        rootComponentClass: selfAt this point we can begin to download our feed at *http://localhost:8080/todo.rss*, however it is mostly empty except for some standard markup as shown by the following RSS file.@@note Your browser may be set up to handle RSS feeds automatically, so you may have difficulty in examining the raw source.=<?xml version="1.0" encoding="utf-8"?>=<rss version="2.0">=    <channel>=    </channel>=</rss>