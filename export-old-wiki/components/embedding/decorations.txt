Sometimes we would like to reuse a component while adding something to it, such as an information message or extra buttons. Seaside has facilities for doing this. In Seaside parlance, this is called ``decorating\'' a component. Note that this is ''not'' implemented using the design pattern of the same name, but rather as a ''Chain of Responsibility''. This means that decorations form a chain of special components into which your component is inserted, and that a given message pass through the chain of decorators.Decorations can be added to any component by calling +index:WAComponent!addDecoration:+ ==WAComponent>>addDecoration:==. Decorations are used to change the behavior or the look of the decorated component.A component decoration is static in the sense that it should not change after the component has been rendered. Thus, a decoration should be attached to a component either just after it (the decorator) is created, or just before the component is passed as argument of a ==call:== message==self call: (aComponent==    addDecoration: aDecoration; ==    yourself)There are three kinds of decorations:- ""Visual Decorations."" These change a visual aspect of the decorated component: +index:WAMessageDecoration+ ==WAMessageDecoration== renders a heading above the component; +index:WAFormDecoration+ ==WAFormDecoration== renders a form with buttons around the component; and +index:WAWindowDecoration+ ==WAWindowDecoration== renders a border with a close widget around the component.- ""Behavioral Decorations."" These allow you to add some common behaviours to your components: +index:WAValidationDecoration+ ==WAValidationDecoration== allows you to add validation of the answer-argument and the display of an error message.- ""Internal Decorations."" These support internal logic that you will use when building complex applications: +index:WADelegation+ ==WADelegation== is used to implement the ==call:== message; +index:WAAnswerHandler+ ==WAAnswerHandler== is used to handle the ==answer:== message.