Suppose you wanted a component that shows only the name and email of our ==ContactView== component. There are no special facilities in Seaside for doing this, so you may be tempted to use template methods and specialize hooks in the subclasses. This may lead to the definition of empty methods in subclasses and may force you to define as many subclasses as situations you want to cover, for example if you want to create a ==SimpleContactView== and a ==ReadyonlyContactView==.An alternative approach is to build more advanced components using the messages ==perform:== or ==perform:with:== with a list of method selectors to be sent:==setOutlineForm==    "should be called during action phase"==    methods :=  #(renderNameOn: renderEmailOn:)==renderContentOn: html==   methods do: [ :each | self perform: each with: html ] You can also define a component whose rendering depends on whether it is embedded. Here is an example where the rendering method does not wrap its content in a form tag when the component is in embedded mode (i.e., when it would expect its parent to have already created a form in which to embed this component).  A better way of doing this would be to use a ==FormDecorator== as shown in *ref:../decorations*.==EmbeddableFormComponent>>renderContent: html body: aBlock==    self embedded==        ifTrue: [ aBlock value ]==        ifFalse: [ html form: aBlock ]==EmbeddableFormComponent>>renderContentOn: html==    self renderContent: html body: [==        "lots of form elements get rendered here"==        self renderSaveOn: html ]This would then be embedded by another component using code like:==ContainingComponent>>renderContentOn: html==    html form: [==        "some form elements here, followed by our embeddable Component:"==        html render: (EmbeddableFormComponent new beEmbedded; yourself) ]If you need more sophisticated dynamic control over the rendering of your component, you may want to use ''Magritte'' with Seaside. Magritte is a framework which allows you to define ''descriptions'' for your domain objects. It then uses these descriptions to perform automatic actions (loading, saving, generating SQL...). The Magritte/Seaside integration allows one to automatically  generate forms and Seaside components from domain object described with Magritte descriptions, see *ref:/book/advanced/magritte*. Magritte also offers ways to construct different views on the same objects and so the possibility to create multiple varieties of components: either by selecting a subset of fields to display, or by offering read-only or editable components. As such, it is an extremely useful addition to plain Seaside.+readonly-contact-view|width=75%+