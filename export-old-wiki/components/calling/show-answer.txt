+index:WAComponent!show:+ +index:WAComponent!onAnswer:+ This section explains the method ==show:== in ==WAComponent==. ==show:== is a variation of ==call:==. You may want to skip this section if you are new to Seaside. You will find it helpful later on if you need to have more control on how components replace each other.The method ==show:== passes the control from the receiving component to the component given as the first argument. As with ==call:== the receiver will be temporarily replaced by ==aComponent==. However, as opposed to ==call:==, ==show:== does not block the flow of control and immediately returns.If we replace the ==call:== in the method ==editContact:== with ==show:== the application does not behave the same way as before anymore:==ContactListView>>editContact: aContact==    | view |==    view := ContactView new.==    view contact: aContact.==    self show: view.==    self inform: 'Thanks for editing  ' , aContact nameThe reason is that ==show:== does not block and the confirmation is displayed immediately, effectively replacing the ==ContactView==. Clicking on the ''Ok'' then reveals the ==ContactView==. Of course this is not the intended behavior. We can fix this issue by assigning an answer handler to the view that displays the confirmation:==ContactListView>>editContact: aContact==    | view |==    view := ContactView new.==    view contact: aContact.==    view onAnswer: [ :answer |==        self inform: 'Thanks for editing  ' , aContact name ].==    self show: viewThis solves our problem, but is arguably not very readable. Luckily there is ==show:onAnswer:== that combines the two method calls:==ContactListView>>editContact: aContact==    | view |==    view := ContactView new.==    view contact: aContact.==    self show: view onAnswer: [ :answer |==        self inform: 'Thanks for editing  ' , aContact name ]In fact, what we did above is continuation-passing style. Like this we can emulate the blocking behavior of ==call:== by using ==show:== and a block that defines what happens afterwards. Any code that uses ==call:== can be transformed like this, however in case of loops that can become quite complicated (see *ref:transforming*).