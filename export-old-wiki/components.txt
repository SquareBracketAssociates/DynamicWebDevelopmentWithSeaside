This part describes the core of Seaside: its component model. In Seaside, components are generally designed to have a direct relationship with the state of some part of the underlying model, and to take advantage of their state to change the way they display themselves and interact with the user. The fact that this state is encapsulated locally in the component, rather than stored globally as ``session state\'', sets Seaside apart from most other web application development frameworks. For example, a list can be made responsible for holding the currently selected item or a calendar the currently selected date. In fact, you've already started building your applications this way: in *ref:/book/fundamentals/forms* the ==ContactView== knew which contact it was editing. Understanding how best to use these stateful components, and how to build interactions between them, allows us to build widgets just as we would for desktop applications.You have already seen how components can be created and how they can display themselves on the web page. This section will demonstrate how you can have more control over these processes and how components can interact with other components. You will see two forms of interaction. A component can ''embed'' content and functionality from other components into its own web page; alternatively, it can ''call'' other components, allowing them to take over its web page until they return a result to the main component. ''Tasks'' can be used to give more control over these interactions. You will also see how a pre-defined component can be given different behaviour and appearance to allow it to be re-used in different ways. This reuse is achieved in Seaside via component ''decoration''. Finally, you will see a discussion of ``Slime\'', which despite its name is an extremely useful library to check and validate your Seaside code.