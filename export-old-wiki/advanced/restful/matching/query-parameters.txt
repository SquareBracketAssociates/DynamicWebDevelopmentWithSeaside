So far we used the request type (*ref:../http-method*), the content type (*ref:../content-type*) and the request path (*ref:../request-path*) to dispatch requests to methods. The last method which is also the most powerful one, is to dispatch on specific path elements and query parameters.Using the annotation ==<path:>== we can define flexible masks to extract elements of an URI. The method containing method is triggered when the path matches verbatim. Variable parts in the path definition are enclosed in curly braces =={aString}== and will be assigned to method arguments. Variable repeated parts in the path definition are enclosed in stars ==\*anArray\*== and will be assigned as an array to method arguments.The following example implements a search listing for our todo application. Note that the code is almost exactly the same as the one we had in our initial example, except that it filters for the query string:==ToDoHandler>>searchFor: aString==   <get>==   <path: '/search?query={aString}'>====   ^ String streamContents: [ :stream |==      ToDoList default items do: [ :each |==         (each title includesSubString: aString)==            ifTrue: [ stream nextPutAll: each title; crlf ] ] ]The method is executed when the client sends a GET request which starts with the path ==/search== and contains the query parameter ==query==. The expression =={aString}== makes sure that the method argument ==aString== is bound to that request argument.Give it a try on the console. With the right query string only the todo items with the respective substring are printed:=$ curl http://localhost:8080/todo-api/search?query=REST=Give REST a try