REST (Representational State Transfer) refers to an architectural model for the design of web services. It was defined by Roy Fielding in his dissertation on *Architectural Styles and the Design of Network-based Software Architectures>http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm*. The REST architecture is based on the following simple ideas:- REST uses URIs to refer to and to access resources.- REST is built on top of the stateless HTTP 1.1 protocol. - REST uses HTTP commands to define operations.This last point is essential in REST architecture. HTTP commands have precise semantics:- GET lists or retrieves a resource at a given URI. +index:REST!GET+- PUT replaces or updates a resource at a given URI. +index:REST!PUT+- POST creates a resources at a given URI. +index:REST!POST+- DELETE removes the resources at a given URI. +index:REST!DELETE+Seaside takes a different approach by default: Seaside generates URIs automatically, Seaside keeps state on the server, and Seaside does not interact well with HTTP commands. While the approach of Seaside simplifies a lot of things in web development, sometimes it is necessary to play with the rules. REST is used by a large number of web products and adhering to the REST standard might increase the usability of an application.REST applications with Seaside can take two shapes: The first approach creates or extends the interoperability of an existing application by adding a REST API. Web browsers and other client applications can (programmatically) access the functionality and data of an application server, see *ref:first-architecture*.+first-architecture|width=80%+A second approach consists of using REST as the back-end of an application and make it a fundamental element of its architecture. All objects are exposed via REST services to potential clients as well as to the other parts of the application such as its Seaside user-interface, see *ref:second-architecture*.+second-architecture|width=80%+This second approach offers a low coupling and eases deployment. Load-balacing and fail-over mechanisms can easily be put in place and the application can be distributed over multiple machines.With Seaside and its Rest package you can implement both architectures. In this chapter we are going to look at the first example only, that is we will extend an existing application with a REST API.