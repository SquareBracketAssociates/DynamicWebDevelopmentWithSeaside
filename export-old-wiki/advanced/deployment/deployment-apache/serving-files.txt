Most web applications consist of serving static files at one point or the other. These are all files that don't change over time, as opposed to the XHTML of the web applications. Common static files are style sheets, Javascript code, images, videos, sound or simply document files. As we have seen in *ref:/book/in-action/serving-files* such files can be easily served through the image, however the same drawbacks apply here as those listed in *ref:/book/advanced/deployment/deployment-apache*.The simplest way to use an external file server is to overlay a directory tree on the hard disk of the web server over the Seaside application. For example, when someone requests the file *http://www.appname.com/seaside.png* the server serves the file ==/srv/appname/web/seaside.png==. With Apache this can be done with a few additional statements in the configuration file:=<VirtualHost *>==    # set server name=    ProxyPreserveHost On=    ServerName www.appname.com=    =    # configure static file serving=    DocumentRoot /srv/appname/web=    <Directory /srv/appname/web>=        Order deny,allow=        Allow from all=    </Directory>=    =    # rewrite incoming requests=    RewriteEngine On=    RewriteCond /srv/appname/web%{REQUEST_FILENAME} !-f=    RewriteRule ^/(.*)$ http://localhost:8080/appname/$1 [proxy,last]==</VirtualHost>The added part starts line 9 with the  comment ==#configure static file serving==. Line 9 and following mark a location on the local harddisc to be used as the source of files. So when someone requests the file *http://www.appname.com/seaside.png* Apache will try to serve the file found at ==/srv/appname/web/seaside.png==. For security reasons, the default Apache setup forbids serving any files from the local hard disk, even if the filesystem permissions allow the process to access these files. With the lines between ==Directory== and ==Directory== we specify that Apache can serve all files within ==/srv/appname/web==. There are many more configuration options available there, so check out the Apache documentation.The next thing we have to do is add a condition in front of our rewrite rule. As you certainly remember, this rewrite rule passes (proxies) all incoming requests to Seaside. Now, we would only like to do this if the requested file does not exist on the file-system. To take the previous example again, if somebody requests *http://www.appname.com/seaside.png* Apache should check if a file named ==/srv/appname/web/seaside.png== exists. This is the meaning of the line 16 where ==%{REQUEST_FILENAME}== is a variable representing the file looked up, here the variable  ==REQUEST_FILENAME== is bound to ==seaside.png==. Furthermore, the cryptic expression ==!-f== means that the following rewrite rule should conditionally be executed ''if the file specified does not exist''. In our case, assuming the file ==/srv/appname/web/seaside.png== exists, this means that the rewrite rule is skipped and Apache does the default request handling. Which is to serve the static files as specified with the ==DocumentRoot== directive. Most other requests, assuming that there are only a few files in ==/srv/appname/web==, are passed on to Seaside.A typical layout of the directory ==/srv/appname/web== might look like this:|{ ==favicon.ico== | A shortcut icon, which most graphical web browsers automatically  make use of. The icon is typically displayed next to the URL and within the list of bookmarks.|{ ==robots.txt== | A robots exclusion standard, which most search engines request to get information on what parts of the site should be indexed.|{ ==resources/== | A subdirectory of resources used by the graphical designer of your application.|{ ==resources/css/== | All the CSS resources of your application.|{ ==resources/script/== | All the external Javascript files of your application.