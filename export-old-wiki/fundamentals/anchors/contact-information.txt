In the next few chapters we will develop a simple application, named iAddress, whichmanages an email address book. We will begin by creating a new category ==iAddress==, and creating in this category a class whose instances will represent the contacts in our address book. ==Object subclass: #Contact==    instanceVariableNames: 'name emailAddress'==    classVariableNames: 'Database'==    poolDictionaries: ''==    category: 'iAddress'On the instance side, add the following methods:==Contact>>emailAddress==    ^ emailAddress==Contact>>emailAddress: aString==    emailAddress := aString==Contact>>name==    ^ name==Contact>>name: aString==    name := aStringNext we provide an instance creation method and a method that creates a sample database of ==Contact== instances. Note that these are ''class side'' methods, and should be put in an ==initialization== method category.==Contact class>>name: nameString emailAddress: emailString==    ^ self new==          name: nameString;==          emailAddress: emailString;==          yourself==Contact class>>createSampleDatabase==    Database := OrderedCollection new==        add: (self name: 'Bob Jones' emailAddress: 'bob@nowhere.com');==        add: (self name: 'Steve Smith' emailAddress: 'sm@somewhere.com');==        yourselfThree more ==accessing== methods should be added to the class side:==Contact class>>contacts==    "Answers an OrderedCollection of the contact information instances."====    Database isNil ifTrue: [ self createSampleDatabase ].==    ^ Database==Contact class>>addContact: aContact==    self contacts add: aContact==Contact class>>removeContact: aContact==    self contacts remove: aContactWe use the class variable named ==Database== to store an ==OrderedCollection== of ==Contact== instances. Note that as you work with this class, you can always reset the database by evaluating the following expression.==Contact createSampleDatabase